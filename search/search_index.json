{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Django REST Framework API Key API key permissions for Django REST Framework Introduction \u00b6 Django REST Framework API Key is a powerful library for allowing server-side clients to safely use your API. These clients are typically third-party backends and services (i.e. machines ) which do not have a user account but still need to interact with your API in a secure way. Features \u00b6 \u270c\ufe0f Simple to use : create, view and revoke API keys via the admin site, or use built-in helpers to create API keys programmatically. \ud83d\udd12 As secure as possible : API keys are treated with the same level of care than user passwords. They are hashed using the default password hasher before being stored in the database, and only visible at creation. \ud83c\udfa8 Customizable : satisfy specific business requirements by building your own customized API key models, permission classes and admin panels. Should I use API keys? \u00b6 There are important security aspects you need to consider before switching to an API key access control scheme. We've listed some of these in Security caveats , including serving your API over HTTPS. Besides, see Why and when to use API keys for hints on whether API keys can fit your use case. API keys are ideal in the following situations: Blocking anonymous traffic. Implementing API key-based throttling . (Note that Django REST Framework already has many built-in utilities for this use case.) Identifying usage patterns by logging request information along with the API key. They can also present enough security for authorizing internal services, such as your API server and an internal frontend application. Warning Please note that this package is NOT meant for authentication. You should NOT use this package to identify individual users, either directly or indirectly. If you need server-to-server authentication, you may want to consider OAuth instead. Libraries such as django-oauth-toolkit can help. Quickstart \u00b6 Install with pip : pip install \"djangorestframework-api-key==2.*\" Important It is highly recommended to pin your dependency to the latest major version (as depicted above), as breaking changes may and will happen between major releases. Add the app to your INSTALLED_APPS : # settings.py INSTALLED_APPS = [ # ... \"rest_framework\" , \"rest_framework_api_key\" , ] Run the included migrations: python manage.py migrate To learn how to configure permissions and manage API keys, head to the User Guide .","title":"Home"},{"location":"#introduction","text":"Django REST Framework API Key is a powerful library for allowing server-side clients to safely use your API. These clients are typically third-party backends and services (i.e. machines ) which do not have a user account but still need to interact with your API in a secure way.","title":"Introduction"},{"location":"#features","text":"\u270c\ufe0f Simple to use : create, view and revoke API keys via the admin site, or use built-in helpers to create API keys programmatically. \ud83d\udd12 As secure as possible : API keys are treated with the same level of care than user passwords. They are hashed using the default password hasher before being stored in the database, and only visible at creation. \ud83c\udfa8 Customizable : satisfy specific business requirements by building your own customized API key models, permission classes and admin panels.","title":"Features"},{"location":"#should-i-use-api-keys","text":"There are important security aspects you need to consider before switching to an API key access control scheme. We've listed some of these in Security caveats , including serving your API over HTTPS. Besides, see Why and when to use API keys for hints on whether API keys can fit your use case. API keys are ideal in the following situations: Blocking anonymous traffic. Implementing API key-based throttling . (Note that Django REST Framework already has many built-in utilities for this use case.) Identifying usage patterns by logging request information along with the API key. They can also present enough security for authorizing internal services, such as your API server and an internal frontend application. Warning Please note that this package is NOT meant for authentication. You should NOT use this package to identify individual users, either directly or indirectly. If you need server-to-server authentication, you may want to consider OAuth instead. Libraries such as django-oauth-toolkit can help.","title":"Should I use API keys?"},{"location":"#quickstart","text":"Install with pip : pip install \"djangorestframework-api-key==2.*\" Important It is highly recommended to pin your dependency to the latest major version (as depicted above), as breaking changes may and will happen between major releases. Add the app to your INSTALLED_APPS : # settings.py INSTALLED_APPS = [ # ... \"rest_framework\" , \"rest_framework_api_key\" , ] Run the included migrations: python manage.py migrate To learn how to configure permissions and manage API keys, head to the User Guide .","title":"Quickstart"},{"location":"guide/","text":"User Guide \u00b6 Getting started \u00b6 Installation \u00b6 Install from PyPI: pip install djangorestframework-api-key Note : this package requires Python 3.7+, Django 2.0+ and Django REST Framework 3.8+. Project setup \u00b6 Add the app to your INSTALLED_APPS : # settings.py INSTALLED_APPS = [ # ... \"rest_framework\" , \"rest_framework_api_key\" , ] Run the included migrations: python manage.py migrate Setting permissions \u00b6 The HasAPIKey permission class protects a view behind API key authorization. You can set the permission globally: # settings.py REST_FRAMEWORK = { \"DEFAULT_PERMISSION_CLASSES\" : [ \"rest_framework_api_key.permissions.HasAPIKey\" , ] } or on a per-view basis: # views.py from rest_framework.views import APIView from rest_framework_api_key.permissions import HasAPIKey class UserListView ( APIView ): permission_classes = [ HasAPIKey ] # ... See also Setting the permission policy for more information on using permission classes in the Django REST Framework. Tip You can use the bitwise operators | and & to compose HasAPIKey with other permission classes and achieve more complex authorization behaviour. For example, to require a valid API key or authentication credentials, use: from rest_framework.permissions import IsAuthenticated from rest_framework_api_key.permissions import HasAPIKey # ... permission_classes = [ HasAPIKey | IsAuthenticated ] Making authorized requests \u00b6 Authorization header \u00b6 By default, clients must pass their API key via the Authorization header. It must be formatted as follows: Authorization: Api-Key <API_KEY> where <API_KEY> refers to the full generated API key (see Creating and managing API keys below). To know under which conditions access is granted, please see Grant scheme . If wanting to also customize the keyword used for parsing the Api-Key, please see API key Custom Keyword Custom header \u00b6 You can set the API_KEY_CUSTOM_HEADER setting to a non- None value to require clients to pass their API key in a custom header instead of the Authorization header. This is useful if you plan to use API keys AND an authentication scheme which already uses the Authorization header (e.g. token-based authentication). For example, if you set: # settings.py API_KEY_CUSTOM_HEADER = \"HTTP_X_API_KEY\" then clients must make authorized requests using: X-Api-Key: <API_KEY> where <API_KEY> refers to the full generated API key. Please refer to HttpRequest.META for more information on headers in Django. Creating and managing API keys \u00b6 Admin site \u00b6 When it is installed, djangorestframework-api-key adds an \"API Key Permissions\" section to the Django admin site where you can create, view and revoke API keys. Note Upon creating an API key from the admin, the full API key is shown only once in a success message banner. This is what should be passed in authorization headers. After creation, only the prefix of the API key is shown in the admin site, mostly for identification purposes. If you lose the full API key, you'll need to regenerate a new one. Programmatic usage \u00b6 API keys can be created, viewed and revoked programmatically by manipulating the APIKey model. Note The examples below use the Django shell . You can view and query APIKey like any other model. For example, to know the total number of API keys: >>> from rest_framework_api_key.models import APIKey >>> APIKey . objects . count () 42 If you wish to create an API key programmatically, you'll most likely want a one-time access to its generated key too. To do so, use the .create_key() method on the APIKey objects manager instead of .create() : >>> from rest_framework_api_key.models import APIKey >>> api_key , key = APIKey . objects . create_key ( name = \"my-remote-service\" ) >>> # Proceed with `api_key` and `key`... Danger To prevent leaking API keys, you must only give the key to the client that triggered its generation . In particular, do not keep any trace of it on the server . To retrieve an APIKey instance based on its generated key (which is not stored in the database) use the .get_from_key() method on the APIKey objects manager instead of .get() . This is useful if you'd like to access an APIKey object from a view protected by a HasAPIKey permission. from rest_framework.views import APIView from rest_framework_api_key.models import APIKey from rest_framework_api_key.permissions import HasAPIKey from .models import Project class ProjectListView ( APIView ): permission_classes = [ HasAPIKey ] def get ( self , request ): \"\"\"Retrieve a project based on the request API key.\"\"\" key = request . META [ \"HTTP_AUTHORIZATION\" ] . split ()[ 1 ] api_key = APIKey . objects . get_from_key ( key ) project = Project . objects . get ( api_key = api_key ) Customization \u00b6 This package provides various customization APIs that allow you to extend its basic behavior. API key models \u00b6 If the built-in APIKey model doesn't fit your needs, you can create your own by subclassing AbstractAPIKey . This is particularly useful if you need to store extra information or link API keys to other models using a ForeignKey or a ManyToManyField . Warning Associating API keys to users, directly or indirectly, can present a security risk. See also: Should I use API keys? . Example \u00b6 Here's how you could link API keys to an imaginary Organization model: # organizations/models.py from django.db import models from rest_framework_api_key.models import AbstractAPIKey class Organization ( models . Model ): name = models . CharField ( max_length = 128 ) active = models . BooleanField ( default = True ) class OrganizationAPIKey ( AbstractAPIKey ): organization = models . ForeignKey ( Organization , on_delete = models . CASCADE , related_name = \"api_keys\" , ) If you need to customize the model's Meta , it should inherit from AbstractAPIKey.Meta : class OrganizationAPIKey ( AbstractAPIKey ): # ... class Meta ( AbstractAPIKey . Meta ): verbose_name = \"Organization API key\" verbose_name_plural = \"Organization API keys\" Migrations \u00b6 Because AbstractAPIKey is an abstract model , the custom API key model will have its own table in the database. This means that you need to generate a migration and then apply it to be able to query the new API key model: python manage.py makemigrations python manage.py migrate Important If AbstractAPIKey changes (e.g. because of an update to Django REST Framework API Key), you will need to generate and apply migrations again to account for these changes. Managers \u00b6 The APIKey model as well as custom API keys models inherited from AbstractAPIKey have a dedicated manager which is responsible for implementing .create_key() and other important behavior. As a result, if you want to build a custom API key manager, it should inherit from BaseAPIKeyManager instead of Django's Manager . Besides customization APIs that come with Django's managers , BaseAPIKeyManager gives you one extra hook: you can override .get_usable_keys() to customize which set of API keys clients can use in authorized requests. For example, here's how to restrict usable keys to those of active organizations only: class OrganizationAPIKeyManager ( BaseAPIKeyManager ): def get_usable_keys ( self ): return super () . get_usable_keys () . filter ( organization__active = True ) Check Note the call to the parent implementation using super() here. This is because .get_usable_keys() has some default behavior, including making sure that revoked API keys cannot be used. Tip You don't need to use a custom model to use a custom manager \u2014 it can be used on the built-in APIKey model as well. Admin panel \u00b6 If you'd like to view and manage your custom API key model via the Django admin site , you can create and register a subclass of APIKeyModelAdmin : # organizations/admin.py from django.contrib import admin from rest_framework_api_key.admin import APIKeyModelAdmin from .models import OrganizationAPIKey @admin . register ( OrganizationAPIKey ) class OrganizationAPIKeyModelAdmin ( APIKeyModelAdmin ): pass You can also customize any of the default attributes defined in APIKeyModelAdmin . For example, to display the organization's name in the list view, and allow searching OrganizationAPIKey instances by organization name while keeping the original search behavior, you can write: list_display = [ * APIKeyModelAdmin . list_display , \"organization__name\" ] search_fields = [ * APIKeyModelAdmin . search_fields , \"organization__name\" ] How can I display API keys on the detail page of a related model instance? In theory, this could be done using Django's InlineModelAdmin . However, due to the limitations of inlines, this cannot be easily achieved while correctly saving and displaying the generated key in the detail page of the related model. As an alternative, you can use the .list_filter class attribute to filter API keys by an identifying field on the related model. In the examples above, you could use organization__name to filter API keys by organization. Permission classes \u00b6 The built-in HasAPIKey permission class only checks against the built-in APIKey model. This means that if you use a custom API key model, you need to create a custom permission class for your application to validate API keys against it. You can do so by subclassing BaseHasAPIKey and specifying the .model class attribute: # organizations/permissions.py from rest_framework_api_key.permissions import BaseHasAPIKey from .models import OrganizationAPIKey class HasOrganizationAPIKey ( BaseHasAPIKey ): model = OrganizationAPIKey You can then use HasOrganizationAPIKey as described in Setting permissions . Tip If you need to customize .has_permission() or .has_object_permission() , feel free to read the source code . API key parsing \u00b6 By default, API key permission classes retrieve the API key from the Authorization header or a custom header, as described in Making authorized requests . You can customize or override this behavior in several ways. If you are building an API for an application you do not control that requires a specific header keyword, e.g. a client that sends API keys using the Bearer keyword as follows: Authorization: Bearer <API_KEY> Then you can subclass KeyParser with a custom keyword , and attach it to a custom permission class, like so: # settings.py from rest_framework_api_key.models import HasAPIKey from rest_framework_api_key.permissions import BaseHasAPIKey , KeyParser class BearerKeyParser ( KeyParser ): keyword = \"Bearer\" class HasAPIKey ( BaseHasAPIKey ): model = APIKey # Or a custom model key_parser = BearerKeyParser () You can also override the default header-based parsing completely. To do so, redefine the .get_key() method on your custom permission class. This method accepts the HttpRequest object as unique argument and should return the API key as an str if one was found, or None otherwise. For example, here's how you could retrieve the API key from a cookie: class HasAPIKey ( BaseHasAPIKey ): model = APIKey # Or a custom model def get_key ( self , request ): return request . COOKIES . get ( \"api_key\" ) If your custom key parsing algorithm is more complex, you may want to define it as a separate component. To do so, build a key parser class, which must implement the .get() method with the same signature as .get_key() , then set it as the .key_parser , as follows: class CookieKeyParser : def get ( self , request ): cookie_name = getattr ( settings , \"API_KEY_COOKIE_NAME\" , \"api_key\" ) return request . COOKIES . get ( cookie_name ) class HasAPIKey ( BaseHasAPIKey ): model = APIKey # Or a custom model key_parser = CookieKeyParser () Key generation \u00b6 Warning This is an advanced topic . Customizing the key generation algorithm must be done with care to prevent security issues. If you proceed, it is best to customize key generation with a clean database state , that is before running initial migrations , and more importantly before any API key is created . This package ships with a key generation algorithm based on Django's password hashing infrastructure (see also Security ). The .key_generator attribute on BaseAPIKeyManager allows you to customize key generation. For example, you can customize the length of the prefix and secret key using: from rest_framework_api_key.models import BaseAPIKeyManager from rest_framework_api_key.crypto import KeyGenerator class OrganizationAPIKeyManager ( BaseAPIKeyManager ): key_generator = KeyGenerator ( prefix_length = 8 , secret_key_length = 32 ) # Default values class OrganizationAPIKey ( AbstractAPIKey ): objects = OrganizationAPIKeyManager () # ... If you want to replace the key generation algorithm entirely, you can create your own KeyGenerator class. It must implement the .generate() and .verify() methods. At this point, it's probably best to read the source code for the built-in KeyGenerator . Check If the signature of your .generate() method is different from the built-in one, you'll need to override .assign_key() in your custom API key manager as well. Likewise, if .verify() must accept anything else than the key and hashed_key , you'll need to override .is_valid() on your custom API key model. See models.py for the source code of BaseAPIKeyManager . Typing support \u00b6 This package provides type information starting with version 2.0, making it suitable for usage with type checkers such as mypy . For the best experience, you may want to install packages such as django-stubs and djangorestframework-stubs . Note however that a seamless integration with these packages is not guaranteed yet.","title":"User Guide"},{"location":"guide/#user-guide","text":"","title":"User Guide"},{"location":"guide/#getting-started","text":"","title":"Getting started"},{"location":"guide/#installation","text":"Install from PyPI: pip install djangorestframework-api-key Note : this package requires Python 3.7+, Django 2.0+ and Django REST Framework 3.8+.","title":"Installation"},{"location":"guide/#project-setup","text":"Add the app to your INSTALLED_APPS : # settings.py INSTALLED_APPS = [ # ... \"rest_framework\" , \"rest_framework_api_key\" , ] Run the included migrations: python manage.py migrate","title":"Project setup"},{"location":"guide/#setting-permissions","text":"The HasAPIKey permission class protects a view behind API key authorization. You can set the permission globally: # settings.py REST_FRAMEWORK = { \"DEFAULT_PERMISSION_CLASSES\" : [ \"rest_framework_api_key.permissions.HasAPIKey\" , ] } or on a per-view basis: # views.py from rest_framework.views import APIView from rest_framework_api_key.permissions import HasAPIKey class UserListView ( APIView ): permission_classes = [ HasAPIKey ] # ... See also Setting the permission policy for more information on using permission classes in the Django REST Framework. Tip You can use the bitwise operators | and & to compose HasAPIKey with other permission classes and achieve more complex authorization behaviour. For example, to require a valid API key or authentication credentials, use: from rest_framework.permissions import IsAuthenticated from rest_framework_api_key.permissions import HasAPIKey # ... permission_classes = [ HasAPIKey | IsAuthenticated ]","title":"Setting permissions"},{"location":"guide/#making-authorized-requests","text":"","title":"Making authorized requests"},{"location":"guide/#authorization-header","text":"By default, clients must pass their API key via the Authorization header. It must be formatted as follows: Authorization: Api-Key <API_KEY> where <API_KEY> refers to the full generated API key (see Creating and managing API keys below). To know under which conditions access is granted, please see Grant scheme . If wanting to also customize the keyword used for parsing the Api-Key, please see API key Custom Keyword","title":"Authorization header"},{"location":"guide/#custom-header","text":"You can set the API_KEY_CUSTOM_HEADER setting to a non- None value to require clients to pass their API key in a custom header instead of the Authorization header. This is useful if you plan to use API keys AND an authentication scheme which already uses the Authorization header (e.g. token-based authentication). For example, if you set: # settings.py API_KEY_CUSTOM_HEADER = \"HTTP_X_API_KEY\" then clients must make authorized requests using: X-Api-Key: <API_KEY> where <API_KEY> refers to the full generated API key. Please refer to HttpRequest.META for more information on headers in Django.","title":"Custom header"},{"location":"guide/#creating-and-managing-api-keys","text":"","title":"Creating and managing API keys"},{"location":"guide/#admin-site","text":"When it is installed, djangorestframework-api-key adds an \"API Key Permissions\" section to the Django admin site where you can create, view and revoke API keys. Note Upon creating an API key from the admin, the full API key is shown only once in a success message banner. This is what should be passed in authorization headers. After creation, only the prefix of the API key is shown in the admin site, mostly for identification purposes. If you lose the full API key, you'll need to regenerate a new one.","title":"Admin site"},{"location":"guide/#programmatic-usage","text":"API keys can be created, viewed and revoked programmatically by manipulating the APIKey model. Note The examples below use the Django shell . You can view and query APIKey like any other model. For example, to know the total number of API keys: >>> from rest_framework_api_key.models import APIKey >>> APIKey . objects . count () 42 If you wish to create an API key programmatically, you'll most likely want a one-time access to its generated key too. To do so, use the .create_key() method on the APIKey objects manager instead of .create() : >>> from rest_framework_api_key.models import APIKey >>> api_key , key = APIKey . objects . create_key ( name = \"my-remote-service\" ) >>> # Proceed with `api_key` and `key`... Danger To prevent leaking API keys, you must only give the key to the client that triggered its generation . In particular, do not keep any trace of it on the server . To retrieve an APIKey instance based on its generated key (which is not stored in the database) use the .get_from_key() method on the APIKey objects manager instead of .get() . This is useful if you'd like to access an APIKey object from a view protected by a HasAPIKey permission. from rest_framework.views import APIView from rest_framework_api_key.models import APIKey from rest_framework_api_key.permissions import HasAPIKey from .models import Project class ProjectListView ( APIView ): permission_classes = [ HasAPIKey ] def get ( self , request ): \"\"\"Retrieve a project based on the request API key.\"\"\" key = request . META [ \"HTTP_AUTHORIZATION\" ] . split ()[ 1 ] api_key = APIKey . objects . get_from_key ( key ) project = Project . objects . get ( api_key = api_key )","title":"Programmatic usage"},{"location":"guide/#customization","text":"This package provides various customization APIs that allow you to extend its basic behavior.","title":"Customization"},{"location":"guide/#api-key-models","text":"If the built-in APIKey model doesn't fit your needs, you can create your own by subclassing AbstractAPIKey . This is particularly useful if you need to store extra information or link API keys to other models using a ForeignKey or a ManyToManyField . Warning Associating API keys to users, directly or indirectly, can present a security risk. See also: Should I use API keys? .","title":"API key models"},{"location":"guide/#example","text":"Here's how you could link API keys to an imaginary Organization model: # organizations/models.py from django.db import models from rest_framework_api_key.models import AbstractAPIKey class Organization ( models . Model ): name = models . CharField ( max_length = 128 ) active = models . BooleanField ( default = True ) class OrganizationAPIKey ( AbstractAPIKey ): organization = models . ForeignKey ( Organization , on_delete = models . CASCADE , related_name = \"api_keys\" , ) If you need to customize the model's Meta , it should inherit from AbstractAPIKey.Meta : class OrganizationAPIKey ( AbstractAPIKey ): # ... class Meta ( AbstractAPIKey . Meta ): verbose_name = \"Organization API key\" verbose_name_plural = \"Organization API keys\"","title":"Example"},{"location":"guide/#migrations","text":"Because AbstractAPIKey is an abstract model , the custom API key model will have its own table in the database. This means that you need to generate a migration and then apply it to be able to query the new API key model: python manage.py makemigrations python manage.py migrate Important If AbstractAPIKey changes (e.g. because of an update to Django REST Framework API Key), you will need to generate and apply migrations again to account for these changes.","title":"Migrations"},{"location":"guide/#managers","text":"The APIKey model as well as custom API keys models inherited from AbstractAPIKey have a dedicated manager which is responsible for implementing .create_key() and other important behavior. As a result, if you want to build a custom API key manager, it should inherit from BaseAPIKeyManager instead of Django's Manager . Besides customization APIs that come with Django's managers , BaseAPIKeyManager gives you one extra hook: you can override .get_usable_keys() to customize which set of API keys clients can use in authorized requests. For example, here's how to restrict usable keys to those of active organizations only: class OrganizationAPIKeyManager ( BaseAPIKeyManager ): def get_usable_keys ( self ): return super () . get_usable_keys () . filter ( organization__active = True ) Check Note the call to the parent implementation using super() here. This is because .get_usable_keys() has some default behavior, including making sure that revoked API keys cannot be used. Tip You don't need to use a custom model to use a custom manager \u2014 it can be used on the built-in APIKey model as well.","title":"Managers"},{"location":"guide/#admin-panel","text":"If you'd like to view and manage your custom API key model via the Django admin site , you can create and register a subclass of APIKeyModelAdmin : # organizations/admin.py from django.contrib import admin from rest_framework_api_key.admin import APIKeyModelAdmin from .models import OrganizationAPIKey @admin . register ( OrganizationAPIKey ) class OrganizationAPIKeyModelAdmin ( APIKeyModelAdmin ): pass You can also customize any of the default attributes defined in APIKeyModelAdmin . For example, to display the organization's name in the list view, and allow searching OrganizationAPIKey instances by organization name while keeping the original search behavior, you can write: list_display = [ * APIKeyModelAdmin . list_display , \"organization__name\" ] search_fields = [ * APIKeyModelAdmin . search_fields , \"organization__name\" ] How can I display API keys on the detail page of a related model instance? In theory, this could be done using Django's InlineModelAdmin . However, due to the limitations of inlines, this cannot be easily achieved while correctly saving and displaying the generated key in the detail page of the related model. As an alternative, you can use the .list_filter class attribute to filter API keys by an identifying field on the related model. In the examples above, you could use organization__name to filter API keys by organization.","title":"Admin panel"},{"location":"guide/#permission-classes","text":"The built-in HasAPIKey permission class only checks against the built-in APIKey model. This means that if you use a custom API key model, you need to create a custom permission class for your application to validate API keys against it. You can do so by subclassing BaseHasAPIKey and specifying the .model class attribute: # organizations/permissions.py from rest_framework_api_key.permissions import BaseHasAPIKey from .models import OrganizationAPIKey class HasOrganizationAPIKey ( BaseHasAPIKey ): model = OrganizationAPIKey You can then use HasOrganizationAPIKey as described in Setting permissions . Tip If you need to customize .has_permission() or .has_object_permission() , feel free to read the source code .","title":"Permission classes"},{"location":"guide/#api-key-parsing","text":"By default, API key permission classes retrieve the API key from the Authorization header or a custom header, as described in Making authorized requests . You can customize or override this behavior in several ways. If you are building an API for an application you do not control that requires a specific header keyword, e.g. a client that sends API keys using the Bearer keyword as follows: Authorization: Bearer <API_KEY> Then you can subclass KeyParser with a custom keyword , and attach it to a custom permission class, like so: # settings.py from rest_framework_api_key.models import HasAPIKey from rest_framework_api_key.permissions import BaseHasAPIKey , KeyParser class BearerKeyParser ( KeyParser ): keyword = \"Bearer\" class HasAPIKey ( BaseHasAPIKey ): model = APIKey # Or a custom model key_parser = BearerKeyParser () You can also override the default header-based parsing completely. To do so, redefine the .get_key() method on your custom permission class. This method accepts the HttpRequest object as unique argument and should return the API key as an str if one was found, or None otherwise. For example, here's how you could retrieve the API key from a cookie: class HasAPIKey ( BaseHasAPIKey ): model = APIKey # Or a custom model def get_key ( self , request ): return request . COOKIES . get ( \"api_key\" ) If your custom key parsing algorithm is more complex, you may want to define it as a separate component. To do so, build a key parser class, which must implement the .get() method with the same signature as .get_key() , then set it as the .key_parser , as follows: class CookieKeyParser : def get ( self , request ): cookie_name = getattr ( settings , \"API_KEY_COOKIE_NAME\" , \"api_key\" ) return request . COOKIES . get ( cookie_name ) class HasAPIKey ( BaseHasAPIKey ): model = APIKey # Or a custom model key_parser = CookieKeyParser ()","title":"API key parsing"},{"location":"guide/#key-generation","text":"Warning This is an advanced topic . Customizing the key generation algorithm must be done with care to prevent security issues. If you proceed, it is best to customize key generation with a clean database state , that is before running initial migrations , and more importantly before any API key is created . This package ships with a key generation algorithm based on Django's password hashing infrastructure (see also Security ). The .key_generator attribute on BaseAPIKeyManager allows you to customize key generation. For example, you can customize the length of the prefix and secret key using: from rest_framework_api_key.models import BaseAPIKeyManager from rest_framework_api_key.crypto import KeyGenerator class OrganizationAPIKeyManager ( BaseAPIKeyManager ): key_generator = KeyGenerator ( prefix_length = 8 , secret_key_length = 32 ) # Default values class OrganizationAPIKey ( AbstractAPIKey ): objects = OrganizationAPIKeyManager () # ... If you want to replace the key generation algorithm entirely, you can create your own KeyGenerator class. It must implement the .generate() and .verify() methods. At this point, it's probably best to read the source code for the built-in KeyGenerator . Check If the signature of your .generate() method is different from the built-in one, you'll need to override .assign_key() in your custom API key manager as well. Likewise, if .verify() must accept anything else than the key and hashed_key , you'll need to override .is_valid() on your custom API key model. See models.py for the source code of BaseAPIKeyManager .","title":"Key generation"},{"location":"guide/#typing-support","text":"This package provides type information starting with version 2.0, making it suitable for usage with type checkers such as mypy . For the best experience, you may want to install packages such as django-stubs and djangorestframework-stubs . Note however that a seamless integration with these packages is not guaranteed yet.","title":"Typing support"},{"location":"security/","text":"Security \u00b6 Implementation details \u00b6 Key generation scheme \u00b6 An API key is composed of two items: A prefix P , which is a generated string of 8 characters. A secret key SK , which is a generated string of 32 characters. The generated key that clients use to make authorized requests is GK = P.SK . It is treated with the same level of care as passwords: Only a hashed version is stored in the database. The hash is computed using the default password hasher. 1 The generated key is shown only once to the client upon API key creation. Grant scheme \u00b6 Access is granted if and only if all of the following is true: The configured API key header is present and correctly formatted. 2 A usable API key with the prefix of the given key exists in the database. 3 The hash of the given key matches that of the API key. Caveats \u00b6 API keys \u2260 Security : depending on your situation, you should probably not use API keys only to authorize your clients. Besides, it is NOT recommended to use this package for authentication, i.e. retrieving user information from API keys. Indeed, using API keys shifts the responsability of Information Security on your clients . This induces risks, especially if detaining an API key gives access to confidential information or write operations. For example, an attacker could impersonate clients if they let their API keys leak. As a best practice, you should apply the Principle of Least Privilege : allow only those who require resources to access those specific resources. In other words: if your client needs to access an endpoint, add API permissions on that endpoint only instead of the whole API. Besides, it is highly recommended to serve the API over HTTPS to ensure the confidentiality of API keys passed in requests. Act responsibly! All hashers provided by Django should be supported. This package is tested against the default list of PASSWORD_HASHERS . See also How Django stores passwords for more information. \u21a9 To customize this behavior, see API key parsing . \u21a9 Only unrevoked keys are usable by default, but this can be customized with a custom manager . \u21a9","title":"Security"},{"location":"security/#security","text":"","title":"Security"},{"location":"security/#implementation-details","text":"","title":"Implementation details"},{"location":"security/#key-generation-scheme","text":"An API key is composed of two items: A prefix P , which is a generated string of 8 characters. A secret key SK , which is a generated string of 32 characters. The generated key that clients use to make authorized requests is GK = P.SK . It is treated with the same level of care as passwords: Only a hashed version is stored in the database. The hash is computed using the default password hasher. 1 The generated key is shown only once to the client upon API key creation.","title":"Key generation scheme"},{"location":"security/#grant-scheme","text":"Access is granted if and only if all of the following is true: The configured API key header is present and correctly formatted. 2 A usable API key with the prefix of the given key exists in the database. 3 The hash of the given key matches that of the API key.","title":"Grant scheme"},{"location":"security/#caveats","text":"API keys \u2260 Security : depending on your situation, you should probably not use API keys only to authorize your clients. Besides, it is NOT recommended to use this package for authentication, i.e. retrieving user information from API keys. Indeed, using API keys shifts the responsability of Information Security on your clients . This induces risks, especially if detaining an API key gives access to confidential information or write operations. For example, an attacker could impersonate clients if they let their API keys leak. As a best practice, you should apply the Principle of Least Privilege : allow only those who require resources to access those specific resources. In other words: if your client needs to access an endpoint, add API permissions on that endpoint only instead of the whole API. Besides, it is highly recommended to serve the API over HTTPS to ensure the confidentiality of API keys passed in requests. Act responsibly! All hashers provided by Django should be supported. This package is tested against the default list of PASSWORD_HASHERS . See also How Django stores passwords for more information. \u21a9 To customize this behavior, see API key parsing . \u21a9 Only unrevoked keys are usable by default, but this can be customized with a custom manager . \u21a9","title":"Caveats"},{"location":"upgrade/1.0/","text":"Upgrading to 1.0 \u00b6 Introduction \u00b6 The 1.0 release is incompatible with 0.x . It introduces a new and more transparent API key generation and validation scheme which allows to pass it in a single header, instead of two previously. This document lists the steps necessary to upgrade from 0.x to 1.0. Steps \u00b6 1. Backup existing API keys \u00b6 Unfortunately, it is not possible to provide a migration that would preserve existing API keys. This is because the cryptographic generation and validation methods have changed fundamentally, which means that new keys cannot be inferred from existing ones. As a result, all existing API keys will be destroyed during Step 1/ described below. You may want to backup the existing data so that you can regenerate keys notify clients once migration is complete. 2. Reset migrations \u00b6 This step will destroy existing API keys . It is necessary for the new migrations to run correctly. python manage.py migrate rest_framework_api_key zero 3. Upgrade \u00b6 pip install \"djangorestframework-api-key==1.0.*\" 4. Run migrations \u00b6 python manage.py migrate rest_framework_api_key","title":"1.0"},{"location":"upgrade/1.0/#upgrading-to-10","text":"","title":"Upgrading to 1.0"},{"location":"upgrade/1.0/#introduction","text":"The 1.0 release is incompatible with 0.x . It introduces a new and more transparent API key generation and validation scheme which allows to pass it in a single header, instead of two previously. This document lists the steps necessary to upgrade from 0.x to 1.0.","title":"Introduction"},{"location":"upgrade/1.0/#steps","text":"","title":"Steps"},{"location":"upgrade/1.0/#1-backup-existing-api-keys","text":"Unfortunately, it is not possible to provide a migration that would preserve existing API keys. This is because the cryptographic generation and validation methods have changed fundamentally, which means that new keys cannot be inferred from existing ones. As a result, all existing API keys will be destroyed during Step 1/ described below. You may want to backup the existing data so that you can regenerate keys notify clients once migration is complete.","title":"1. Backup existing API keys"},{"location":"upgrade/1.0/#2-reset-migrations","text":"This step will destroy existing API keys . It is necessary for the new migrations to run correctly. python manage.py migrate rest_framework_api_key zero","title":"2. Reset migrations"},{"location":"upgrade/1.0/#3-upgrade","text":"pip install \"djangorestframework-api-key==1.0.*\"","title":"3. Upgrade"},{"location":"upgrade/1.0/#4-run-migrations","text":"python manage.py migrate rest_framework_api_key","title":"4. Run migrations"},{"location":"upgrade/1.4/","text":"Upgrading to 1.4 \u00b6 Introduction \u00b6 The 1.4 release includes a migration that adds and populates the prefix and hashed_key fields to API keys. This document lists the steps necessary to upgrade from 1.3.x to 1.4. Steps \u00b6 1. Migrate the built-in API key model \u00b6 The APIKey model can be migrated using the migration shipped with this package: python manage.py migrate rest_framework_api_key 2. Migrate custom API key models (if applicable) \u00b6 If you have a custom API key model deriving from AbstractAPIKey , you need to manually add the migration to your application. Copy the migration script below to your app's migrations/ directory. Be sure to modify APP_NAME , MODEL_NAME and DEPENDENCIES as seems fit. You can name the migration script xxxx_prefix_hashed_key.py (replace xxxx with the next available migration ID). # Generated by Django 2.2.2 on 2019-06-29 10:38 from django.db import migrations , models APP_NAME = \"rest_framework_api_key\" MODEL_NAME = \"apikey\" DEPENDENCIES = [( APP_NAME , \"0003_auto_20190623_1952\" )] def populate_prefix_hashed_key ( apps , schema_editor ) -> None : # type: ignore model = apps . get_model ( APP_NAME , MODEL_NAME ) for api_key in model . objects . using ( schema_editor . connection . alias ) . all (): prefix , _ , hashed_key = api_key . id . partition ( \".\" ) api_key . prefix = prefix api_key . hashed_key = hashed_key api_key . save () class Migration ( migrations . Migration ): dependencies = DEPENDENCIES operations = [ migrations . AddField ( model_name = MODEL_NAME , name = \"hashed_key\" , field = models . CharField ( max_length = 100 , null = True ), ), migrations . AddField ( model_name = MODEL_NAME , name = \"prefix\" , field = models . CharField ( max_length = 8 , unique = True , null = True ), ), migrations . RunPython ( populate_prefix_hashed_key , migrations . RunPython . noop ), migrations . AlterField ( model_name = MODEL_NAME , name = \"hashed_key\" , field = models . CharField ( max_length = 100 , editable = False ), ), migrations . AlterField ( model_name = MODEL_NAME , name = \"prefix\" , field = models . CharField ( max_length = 8 , unique = True , editable = False ), ), ] Apply the migration: python manage.py migrate <my_app>","title":"1.4"},{"location":"upgrade/1.4/#upgrading-to-14","text":"","title":"Upgrading to 1.4"},{"location":"upgrade/1.4/#introduction","text":"The 1.4 release includes a migration that adds and populates the prefix and hashed_key fields to API keys. This document lists the steps necessary to upgrade from 1.3.x to 1.4.","title":"Introduction"},{"location":"upgrade/1.4/#steps","text":"","title":"Steps"},{"location":"upgrade/1.4/#1-migrate-the-built-in-api-key-model","text":"The APIKey model can be migrated using the migration shipped with this package: python manage.py migrate rest_framework_api_key","title":"1. Migrate the built-in API key model"},{"location":"upgrade/1.4/#2-migrate-custom-api-key-models-if-applicable","text":"If you have a custom API key model deriving from AbstractAPIKey , you need to manually add the migration to your application. Copy the migration script below to your app's migrations/ directory. Be sure to modify APP_NAME , MODEL_NAME and DEPENDENCIES as seems fit. You can name the migration script xxxx_prefix_hashed_key.py (replace xxxx with the next available migration ID). # Generated by Django 2.2.2 on 2019-06-29 10:38 from django.db import migrations , models APP_NAME = \"rest_framework_api_key\" MODEL_NAME = \"apikey\" DEPENDENCIES = [( APP_NAME , \"0003_auto_20190623_1952\" )] def populate_prefix_hashed_key ( apps , schema_editor ) -> None : # type: ignore model = apps . get_model ( APP_NAME , MODEL_NAME ) for api_key in model . objects . using ( schema_editor . connection . alias ) . all (): prefix , _ , hashed_key = api_key . id . partition ( \".\" ) api_key . prefix = prefix api_key . hashed_key = hashed_key api_key . save () class Migration ( migrations . Migration ): dependencies = DEPENDENCIES operations = [ migrations . AddField ( model_name = MODEL_NAME , name = \"hashed_key\" , field = models . CharField ( max_length = 100 , null = True ), ), migrations . AddField ( model_name = MODEL_NAME , name = \"prefix\" , field = models . CharField ( max_length = 8 , unique = True , null = True ), ), migrations . RunPython ( populate_prefix_hashed_key , migrations . RunPython . noop ), migrations . AlterField ( model_name = MODEL_NAME , name = \"hashed_key\" , field = models . CharField ( max_length = 100 , editable = False ), ), migrations . AlterField ( model_name = MODEL_NAME , name = \"prefix\" , field = models . CharField ( max_length = 8 , unique = True , editable = False ), ), ] Apply the migration: python manage.py migrate <my_app>","title":"2. Migrate custom API key models (if applicable)"},{"location":"upgrade/2.0/","text":"Upgrading to 2.0 \u00b6 Introduction \u00b6 This document lists the steps necessary to upgrade from 1.4.x to 2.0. The full list of changes can be found in the Changelog . Steps \u00b6 1. Upgrade your Python to 3.6+ \u00b6 The 2.0 release dropped support for Python 3.5. Before upgrading, make sure you are running on Python 3.6 or above. 2. Upgrade your Django to 2.2+ \u00b6 To 2.0 release dropped official support for Django 2.0 and Django 2.1, which have both reached EOL (see Django: Supported Versions ). Django 2.2 is still supported, and support for Django 3.0 was added. While we there are no internal changes due to this change, you should make sure you are running on Django 2.2 or above before upgrading.","title":"2.0"},{"location":"upgrade/2.0/#upgrading-to-20","text":"","title":"Upgrading to 2.0"},{"location":"upgrade/2.0/#introduction","text":"This document lists the steps necessary to upgrade from 1.4.x to 2.0. The full list of changes can be found in the Changelog .","title":"Introduction"},{"location":"upgrade/2.0/#steps","text":"","title":"Steps"},{"location":"upgrade/2.0/#1-upgrade-your-python-to-36","text":"The 2.0 release dropped support for Python 3.5. Before upgrading, make sure you are running on Python 3.6 or above.","title":"1. Upgrade your Python to 3.6+"},{"location":"upgrade/2.0/#2-upgrade-your-django-to-22","text":"To 2.0 release dropped official support for Django 2.0 and Django 2.1, which have both reached EOL (see Django: Supported Versions ). Django 2.2 is still supported, and support for Django 3.0 was added. While we there are no internal changes due to this change, you should make sure you are running on Django 2.2 or above before upgrading.","title":"2. Upgrade your Django to 2.2+"}]}