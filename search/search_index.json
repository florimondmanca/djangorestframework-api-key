{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Django REST Framework API Key <p>     API key permissions for            Django REST Framework      </p>"},{"location":"#introduction","title":"Introduction","text":"<p>Django REST Framework API Key is a powerful library for allowing server-side clients to safely use your API. These clients are typically third-party backends and services (i.e. machines) which do not have a user account but still need to interact with your API in a secure way.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>\u270c\ufe0f Simple to use: create, view and revoke API keys via the admin site, or use built-in helpers to create API keys programmatically.</li> <li>\ud83d\udd12 As secure as possible: API keys are treated with the same level of care as user passwords. They are only visible at creation and hashed before storing in the database.</li> <li>\ud83c\udfa8 Customizable: satisfy specific business requirements by building your own customized API key models, permission classes and admin panels.</li> </ul>"},{"location":"#should-i-use-api-keys","title":"Should I use API keys?","text":"<p>There are important security aspects you need to consider before switching to an API key access control scheme. We've listed some of these in Security caveats, including serving your API over HTTPS.</p> <p>Besides, see Why and when to use API keys for hints on whether API keys can fit your use case.</p> <p>API keys are ideal in the following situations:</p> <ul> <li>Blocking anonymous traffic.</li> <li>Implementing API key-based throttling. (Note that Django REST Framework already has many built-in utilities for this use case.)</li> <li>Identifying usage patterns by logging request information along with the API key.</li> </ul> <p>They can also present enough security for authorizing internal services, such as your API server and an internal frontend application.</p> <p>Warning</p> <p>Please note that this package is NOT meant for authentication. You should NOT use this package to identify individual users, either directly or indirectly.</p> <p>If you need server-to-server authentication, you may want to consider OAuth instead. Libraries such as django-oauth-toolkit can help.</p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>Install with <code>pip</code>:</p> <pre><code>pip install \"djangorestframework-api-key==2.*\"\n</code></pre> <p>Important</p> <p>It is highly recommended to pin your dependency to the latest major version (as depicted above), as breaking changes may and will happen between major releases.</p> <p>Add the app to your <code>INSTALLED_APPS</code>:</p> <pre><code># settings.py\n\nINSTALLED_APPS = [\n  # ...\n  \"rest_framework\",\n  \"rest_framework_api_key\",\n]\n</code></pre> <p>Run the included migrations:</p> <pre><code>python manage.py migrate\n</code></pre> <p>To learn how to configure permissions and manage API keys, head to the User Guide.</p>"},{"location":"guide/","title":"User Guide","text":""},{"location":"guide/#getting-started","title":"Getting started","text":""},{"location":"guide/#installation","title":"Installation","text":"<p>Install with <code>pip</code>:</p> <pre><code>pip install \"djangorestframework-api-key==2.*\"\n</code></pre> <p>Note: It is highly recommended to pin your dependency to the latest major version (as depicted above), as breaking changes may and will happen between major releases.</p>"},{"location":"guide/#project-setup","title":"Project setup","text":"<p>Add the app to your <code>INSTALLED_APPS</code>:</p> <pre><code># settings.py\n\nINSTALLED_APPS = [\n  # ...\n  \"rest_framework\",\n  \"rest_framework_api_key\",\n]\n</code></pre> <p>Run the included migrations:</p> <pre><code>python manage.py migrate\n</code></pre>"},{"location":"guide/#setting-permissions","title":"Setting permissions","text":"<p>The <code>HasAPIKey</code> permission class protects a view behind API key authorization.</p> <p>You can set the permission globally:</p> <pre><code># settings.py\nREST_FRAMEWORK = {\n    \"DEFAULT_PERMISSION_CLASSES\": [\n        \"rest_framework_api_key.permissions.HasAPIKey\",\n    ]\n}\n</code></pre> <p>or on a per-view basis:</p> <pre><code># views.py\nfrom rest_framework.views import APIView\nfrom rest_framework_api_key.permissions import HasAPIKey\n\nclass UserListView(APIView):\n    permission_classes = [HasAPIKey]\n    # ...\n</code></pre> <p>See also Setting the permission policy for more information on using permission classes in the Django REST Framework.</p> <p>Tip</p> <p>You can use the bitwise operators <code>|</code> and <code>&amp;</code> to compose <code>HasAPIKey</code> with other permission classes and achieve more complex authorization behaviour.</p> <p>For example, to require a valid API key or authentication credentials, use:</p> <pre><code>from rest_framework.permissions import IsAuthenticated\nfrom rest_framework_api_key.permissions import HasAPIKey\n# ...\npermission_classes = [HasAPIKey | IsAuthenticated]\n</code></pre>"},{"location":"guide/#making-authorized-requests","title":"Making authorized requests","text":""},{"location":"guide/#authorization-header","title":"Authorization header","text":"<p>By default, clients must pass their API key via the <code>Authorization</code> header. It must be formatted as follows:</p> <pre><code>Authorization: Api-Key &lt;API_KEY&gt;\n</code></pre> <p>where <code>&lt;API_KEY&gt;</code> refers to the full generated API key (see Creating and managing API keys below).</p> <p>To know under which conditions access is granted, please see Grant scheme.</p> <p>If wanting to also customize the keyword used for parsing the Api-Key, please see API key Custom Keyword</p>"},{"location":"guide/#custom-header","title":"Custom header","text":"<p>You can set the <code>API_KEY_CUSTOM_HEADER</code> setting to a non-<code>None</code> value to require clients to pass their API key in a custom header instead of the <code>Authorization</code> header.</p> <p>This is useful if you plan to use API keys AND an authentication scheme which already uses the <code>Authorization</code> header (e.g. token-based authentication).</p> <p>For example, if you set:</p> <pre><code># settings.py\nAPI_KEY_CUSTOM_HEADER = \"HTTP_X_API_KEY\"\n</code></pre> <p>then clients must make authorized requests using:</p> <pre><code>X-Api-Key: &lt;API_KEY&gt;\n</code></pre> <p>where <code>&lt;API_KEY&gt;</code> refers to the full generated API key.</p> <p>Please refer to HttpRequest.META for more information on headers in Django.</p>"},{"location":"guide/#creating-and-managing-api-keys","title":"Creating and managing API keys","text":""},{"location":"guide/#admin-site","title":"Admin site","text":"<p>When it is installed, <code>djangorestframework-api-key</code> adds an \"API Key Permissions\" section to the Django admin site where you can create, view and revoke API keys.</p> <p>Note</p> <p>Upon creating an API key from the admin, the full API key is shown only once in a success message banner. This is what should be passed in authorization headers. After creation, only the prefix of the API key is shown in the admin site, mostly for identification purposes. If you lose the full API key, you'll need to regenerate a new one.</p>"},{"location":"guide/#programmatic-usage","title":"Programmatic usage","text":"<p>API keys can be created, viewed and revoked programmatically by manipulating the <code>APIKey</code> model.</p> <p>Note</p> <p>The examples below use the Django shell.</p> <ul> <li>You can view and query <code>APIKey</code> like any other model. For example, to know the total number of API keys:</li> </ul> <pre><code>&gt;&gt;&gt; from rest_framework_api_key.models import APIKey\n&gt;&gt;&gt; APIKey.objects.count()\n42\n</code></pre> <ul> <li>If you wish to create an API key programmatically, you'll most likely want a one-time access to its generated key too. To do so, use the <code>.create_key()</code> method on the <code>APIKey</code> objects manager instead of <code>.create()</code>:</li> </ul> <pre><code>&gt;&gt;&gt; from rest_framework_api_key.models import APIKey\n&gt;&gt;&gt; api_key, key = APIKey.objects.create_key(name=\"my-remote-service\")\n&gt;&gt;&gt; # Proceed with `api_key` and `key`...\n</code></pre> <p>Danger</p> <p>To prevent leaking API keys, you must only give the <code>key</code> to the client that triggered its generation. In particular, do not keep any trace of it on the server.</p> <ul> <li>To retrieve an <code>APIKey</code> instance based on its generated key (which is not stored in the database) use the <code>.get_from_key()</code> method on the <code>APIKey</code> objects manager instead of <code>.get()</code>. This is useful if you'd like to access an <code>APIKey</code> object from a view protected by a <code>HasAPIKey</code> permission.</li> </ul> <pre><code>from rest_framework.views import APIView\nfrom rest_framework_api_key.models import APIKey\nfrom rest_framework_api_key.permissions import HasAPIKey\n\nfrom .models import Project\n\nclass ProjectListView(APIView):\n    permission_classes = [HasAPIKey]\n\n    def get(self, request):\n\"\"\"Retrieve a project based on the request API key.\"\"\"\n        key = request.META[\"HTTP_AUTHORIZATION\"].split()[1]\n        api_key = APIKey.objects.get_from_key(key)\n        project = Project.objects.get(api_key=api_key)\n</code></pre>"},{"location":"guide/#customization","title":"Customization","text":"<p>This package provides various customization APIs that allow you to extend its basic behavior.</p>"},{"location":"guide/#api-key-models","title":"API key models","text":"<p>If the built-in <code>APIKey</code> model doesn't fit your needs, you can create your own by subclassing <code>AbstractAPIKey</code>. This is particularly useful if you need to store extra information or link API keys to other models using a <code>ForeignKey</code> or a <code>ManyToManyField</code>.</p> <p>Warning</p> <p>Associating API keys to users, directly or indirectly, can present a security risk. See also: Should I use API keys?.</p>"},{"location":"guide/#example","title":"Example","text":"<p>Here's how you could link API keys to an imaginary <code>Organization</code> model:</p> <pre><code># organizations/models.py\nfrom django.db import models\nfrom rest_framework_api_key.models import AbstractAPIKey\n\nclass Organization(models.Model):\n    name = models.CharField(max_length=128)\n    active = models.BooleanField(default=True)\n\nclass OrganizationAPIKey(AbstractAPIKey):\n    organization = models.ForeignKey(\n        Organization,\n        on_delete=models.CASCADE,\n        related_name=\"api_keys\",\n    )\n</code></pre> <p>If you need to customize the model's <code>Meta</code>, it should inherit from <code>AbstractAPIKey.Meta</code>:</p> <pre><code>class OrganizationAPIKey(AbstractAPIKey):\n    # ...\n    class Meta(AbstractAPIKey.Meta):\n        verbose_name = \"Organization API key\"\n        verbose_name_plural = \"Organization API keys\"\n</code></pre>"},{"location":"guide/#migrations","title":"Migrations","text":"<p>Because <code>AbstractAPIKey</code> is an abstract model, the custom API key model will have its own table in the database.</p> <p>This means that you need to generate a migration and then apply it to be able to query the new API key model:</p> <pre><code>python manage.py makemigrations\npython manage.py migrate\n</code></pre> <p>Important</p> <p>If <code>AbstractAPIKey</code> changes (e.g. because of an update to Django REST Framework API Key), you will need to generate and apply migrations again to account for these changes.</p>"},{"location":"guide/#managers","title":"Managers","text":"<p>The <code>APIKey</code> model as well as custom API keys models inherited from <code>AbstractAPIKey</code> have a dedicated manager which is responsible for implementing <code>.create_key()</code> and other important behavior.</p> <p>As a result, if you want to build a custom API key manager, it should inherit from <code>BaseAPIKeyManager</code> instead of Django's <code>Manager</code>.</p> <p>Besides customization APIs that come with Django's managers, <code>BaseAPIKeyManager</code> gives you one extra hook: you can override <code>.get_usable_keys()</code> to customize which set of API keys clients can use in authorized requests.</p> <p>For example, here's how to restrict usable keys to those of active organizations only:</p> <pre><code>class OrganizationAPIKeyManager(BaseAPIKeyManager):\n    def get_usable_keys(self):\n        return super().get_usable_keys().filter(organization__active=True)\n</code></pre> <p>Check</p> <p>Note the call to the parent implementation using <code>super()</code> here. This is because <code>.get_usable_keys()</code> has some default behavior, including making sure that revoked API keys cannot be used.</p> <p>Tip</p> <p>You don't need to use a custom model to use a custom manager \u2014 it can be used on the built-in <code>APIKey</code> model as well.</p>"},{"location":"guide/#admin-panel","title":"Admin panel","text":"<p>If you'd like to view and manage your custom API key model via the Django admin site, you can create and register a subclass of <code>APIKeyModelAdmin</code>:</p> <pre><code># organizations/admin.py\nfrom django.contrib import admin\nfrom rest_framework_api_key.admin import APIKeyModelAdmin\nfrom .models import OrganizationAPIKey\n\n@admin.register(OrganizationAPIKey)\nclass OrganizationAPIKeyModelAdmin(APIKeyModelAdmin):\n    pass\n</code></pre> <p>You can also customize any of the default attributes defined in <code>APIKeyModelAdmin</code>. For example, to display the organization's name in the list view, and allow searching <code>OrganizationAPIKey</code> instances by organization name while keeping the original search behavior, you can write:</p> <pre><code>    list_display = [*APIKeyModelAdmin.list_display, \"organization__name\"]\n    search_fields = [*APIKeyModelAdmin.search_fields, \"organization__name\"]\n</code></pre> <p>How can I display API keys on the detail page of a related model instance?</p> <p>In theory, this could be done using Django's <code>InlineModelAdmin</code>.</p> <p>However, due to the limitations of inlines, this cannot be easily achieved while correctly saving and displaying the generated key in the detail page of the related model.</p> <p>As an alternative, you can use the <code>.list_filter</code> class attribute to filter API keys by an identifying field on the related model. In the examples above, you could use <code>organization__name</code> to filter API keys by organization.</p>"},{"location":"guide/#permission-classes","title":"Permission classes","text":"<p>The built-in <code>HasAPIKey</code> permission class only checks against the built-in <code>APIKey</code> model. This means that if you use a custom API key model, you need to create a custom permission class for your application to validate API keys against it.</p> <p>You can do so by subclassing <code>BaseHasAPIKey</code> and specifying the <code>.model</code> class attribute:</p> <pre><code># organizations/permissions.py\nfrom rest_framework_api_key.permissions import BaseHasAPIKey\nfrom .models import OrganizationAPIKey\n\nclass HasOrganizationAPIKey(BaseHasAPIKey):\n    model = OrganizationAPIKey\n</code></pre> <p>You can then use <code>HasOrganizationAPIKey</code> as described in Setting permissions.</p> <p>Tip</p> <p>If you need to customize <code>.has_permission()</code> or <code>.has_object_permission()</code>, feel free to read the source code.</p>"},{"location":"guide/#api-key-parsing","title":"API key parsing","text":"<p>By default, API key permission classes retrieve the API key from the <code>Authorization</code> header or a custom header, as described in Making authorized requests.</p> <p>You can customize or override this behavior in several ways.</p> <p>If you are building an API for an application you do not control that requires a specific header keyword, e.g. a client that sends API keys using the <code>Bearer</code> keyword as follows:</p> <pre><code>Authorization: Bearer &lt;API_KEY&gt;\n</code></pre> <p>Then you can subclass <code>KeyParser</code> with a custom <code>keyword</code>, and attach it to a custom permission class, like so:</p> <pre><code># settings.py\nfrom rest_framework_api_key.models import HasAPIKey\nfrom rest_framework_api_key.permissions import BaseHasAPIKey, KeyParser\n\nclass BearerKeyParser(KeyParser):\n    keyword = \"Bearer\"\n\nclass HasAPIKey(BaseHasAPIKey):\n    model = APIKey  # Or a custom model\n    key_parser = BearerKeyParser()\n</code></pre> <p>You can also override the default header-based parsing completely.</p> <p>To do so, redefine the <code>.get_key()</code> method on your custom permission class. This method accepts the HttpRequest object as unique argument and should return the API key as an <code>str</code> if one was found, or <code>None</code> otherwise.</p> <p>For example, here's how you could retrieve the API key from a cookie:</p> <pre><code>class HasAPIKey(BaseHasAPIKey):\n    model = APIKey  # Or a custom model\n\n    def get_key(self, request):\n        return request.COOKIES.get(\"api_key\")\n</code></pre> <p>If your custom key parsing algorithm is more complex, you may want to define it as a separate component. To do so, build a key parser class, which must implement the <code>.get()</code> method with the same signature as <code>.get_key()</code>, then set it as the <code>.key_parser</code>, as follows:</p> <pre><code>class CookieKeyParser:\n    def get(self, request):\n        cookie_name = getattr(settings, \"API_KEY_COOKIE_NAME\", \"api_key\")\n        return request.COOKIES.get(cookie_name)\n\nclass HasAPIKey(BaseHasAPIKey):\n    model = APIKey  # Or a custom model\n    key_parser = CookieKeyParser()\n</code></pre>"},{"location":"guide/#key-generation","title":"Key generation","text":"<p>Warning</p> <p>This is an advanced topic. Customizing the key generation algorithm must be done with care to prevent security issues.</p> <p>If you proceed, it is best to customize key generation with a clean database state, that is before running initial migrations, and more importantly before any API key is created.</p> <p>This package ships with a key generation algorithm based on Django's password hashing infrastructure (see also Security).</p> <p>The <code>.key_generator</code> attribute on <code>BaseAPIKeyManager</code> allows you to customize key generation.</p> <p>For example,  you can customize the length of the prefix and secret key using:</p> <pre><code>from rest_framework_api_key.models import BaseAPIKeyManager\nfrom rest_framework_api_key.crypto import KeyGenerator\n\nclass OrganizationAPIKeyManager(BaseAPIKeyManager):\n    key_generator = KeyGenerator(prefix_length=8, secret_key_length=32)  # Default values\n\nclass OrganizationAPIKey(AbstractAPIKey):\n    objects = OrganizationAPIKeyManager()\n    # ...\n</code></pre> <p>If you want to replace the key generation algorithm entirely, you can create your own <code>KeyGenerator</code> class. It must implement the <code>.generate()</code> and <code>.verify()</code> methods. At this point, it's probably best to read the source code for the built-in <code>KeyGenerator</code>.</p> <p>Check</p> <p>If the signature of your <code>.generate()</code> method is different from the built-in one, you'll need to override <code>.assign_key()</code> in your custom API key manager as well.</p> <p>Likewise, if <code>.verify()</code> must accept anything else than the <code>key</code> and <code>hashed_key</code>, you'll need to override <code>.is_valid()</code> on your custom API key model.</p> <p>See models.py for the source code of <code>BaseAPIKeyManager</code>.</p>"},{"location":"guide/#typing-support","title":"Typing support","text":"<p>This package provides type information starting with version 2.0, making it suitable for usage with type checkers such as <code>mypy</code>.</p> <p>For the best experience, you may want to install packages such as <code>django-stubs</code> and <code>djangorestframework-stubs</code>. Note however that a seamless integration with these packages is not guaranteed yet.</p>"},{"location":"security/","title":"Security","text":""},{"location":"security/#implementation-details","title":"Implementation details","text":""},{"location":"security/#key-generation-scheme","title":"Key generation scheme","text":"<p>An API key is composed of two items:</p> <ul> <li>A prefix <code>P</code>, which is a generated string of 8 characters.</li> <li>A secret key <code>SK</code>, which is a generated string of 32 characters.</li> </ul> <p>The generated key that clients use to make authorized requests is <code>GK = P.SK</code>. It is treated with the same level of care as passwords:</p> <ul> <li>Only a hashed version is stored in the database. The hashing algorithm is sha512. <sup>1</sup></li> <li>The generated key is shown only once to the client upon API key creation.</li> </ul>"},{"location":"security/#grant-scheme","title":"Grant scheme","text":"<p>Access is granted if and only if all of the following is true:</p> <ol> <li>The configured API key header is present and correctly formatted. <sup>2</sup></li> <li>A usable API key with the prefix of the given key exists in the database. <sup>3</sup></li> <li>The hash of the given key matches that of the API key.</li> </ol>"},{"location":"security/#caveats","title":"Caveats","text":"<p>API keys \u2260 Security: depending on your situation, you should probably not use API keys only to authorize your clients.</p> <p>Besides, it is NOT recommended to use this package for authentication, i.e. retrieving user information from API keys.</p> <p>Indeed, using API keys shifts the responsibility of Information Security on your clients. This induces risks, especially if obtaining an API key gives access to confidential information or write operations. For example, an attacker could impersonate clients if they let their API keys leak.</p> <p>As a best practice, you should apply the Principle of Least Privilege: allow only those who require resources to access those specific resources. In other words: if your client needs to access an endpoint, add API permissions on that endpoint only instead of the whole API.</p> <p>Besides, it is highly recommended to serve the API over HTTPS to ensure the confidentiality of API keys passed in requests.</p> <p>Act responsibly!</p> <ol> <li> <p>Older versions of this module used the same hashers as Django's <code>PASSWORD_HASHERS</code>. These hashers come with a large performance penalty and while critical for passwords, they aren't needed for high-entropy, randomly generated keys like the ones created by this module. Keys stored using these slower hashers will be upgraded when used.\u00a0\u21a9</p> </li> <li> <p>To customize this behavior, see API key parsing.\u00a0\u21a9</p> </li> <li> <p>Only unrevoked keys are usable by default, but this can be customized with a custom manager.\u00a0\u21a9</p> </li> </ol>"},{"location":"upgrade/1.0/","title":"Upgrading to 1.0","text":""},{"location":"upgrade/1.0/#introduction","title":"Introduction","text":"<p>The 1.0 release is incompatible with 0.x. It introduces a new and more transparent API key generation and validation scheme which allows to pass it in a single header, instead of two previously.</p> <p>This document lists the steps necessary to upgrade from 0.x to 1.0.</p>"},{"location":"upgrade/1.0/#steps","title":"Steps","text":""},{"location":"upgrade/1.0/#1-backup-existing-api-keys","title":"1. Backup existing API keys","text":"<p>Unfortunately, it is not possible to provide a migration that would preserve existing API keys. This is because the cryptographic generation and validation methods have changed fundamentally, which means that new keys cannot be inferred from existing ones.</p> <p>As a result, all existing API keys will be destroyed during Step 1/ described below. You may want to backup the existing data so that you can regenerate keys notify clients once migration is complete.</p>"},{"location":"upgrade/1.0/#2-reset-migrations","title":"2. Reset migrations","text":"<p>This step will destroy existing API keys. It is necessary for the new migrations to run correctly.</p> <pre><code>python manage.py migrate rest_framework_api_key zero\n</code></pre>"},{"location":"upgrade/1.0/#3-upgrade","title":"3. Upgrade","text":"<pre><code>pip install \"djangorestframework-api-key==1.0.*\"\n</code></pre>"},{"location":"upgrade/1.0/#4-run-migrations","title":"4. Run migrations","text":"<pre><code>python manage.py migrate rest_framework_api_key\n</code></pre>"},{"location":"upgrade/1.4/","title":"Upgrading to 1.4","text":""},{"location":"upgrade/1.4/#introduction","title":"Introduction","text":"<p>The 1.4 release includes a migration that adds and populates the <code>prefix</code> and <code>hashed_key</code> fields to API keys.</p> <p>This document lists the steps necessary to upgrade from 1.3.x to 1.4.</p>"},{"location":"upgrade/1.4/#steps","title":"Steps","text":""},{"location":"upgrade/1.4/#1-migrate-the-built-in-api-key-model","title":"1. Migrate the built-in API key model","text":"<p>The <code>APIKey</code> model can be migrated using the migration shipped with this package:</p> <pre><code>python manage.py migrate rest_framework_api_key\n</code></pre>"},{"location":"upgrade/1.4/#2-migrate-custom-api-key-models-if-applicable","title":"2. Migrate custom API key models (if applicable)","text":"<p>If you have a custom API key model deriving from <code>AbstractAPIKey</code>, you need to manually add the migration to your application.</p> <ul> <li>Copy the migration script below to your app's <code>migrations/</code> directory. Be sure to modify <code>APP_NAME</code>, <code>MODEL_NAME</code> and <code>DEPENDENCIES</code> as seems fit. You can name the migration script <code>xxxx_prefix_hashed_key.py</code> (replace <code>xxxx</code> with the next available migration ID).</li> </ul> <pre><code># Generated by Django 2.2.2 on 2019-06-29 10:38\n\nfrom django.db import migrations, models\n\nAPP_NAME = \"rest_framework_api_key\"\nMODEL_NAME = \"apikey\"\nDEPENDENCIES = [(APP_NAME, \"0003_auto_20190623_1952\")]\n\n\ndef populate_prefix_hashed_key(apps, schema_editor) -&gt; None:  # type: ignore\n    model = apps.get_model(APP_NAME, MODEL_NAME)\n\n    for api_key in model.objects.using(\n        schema_editor.connection.alias\n    ).all():  # pragma: nodj22\n        prefix, _, hashed_key = api_key.id.partition(\".\")\n        api_key.prefix = prefix\n        api_key.hashed_key = hashed_key\n        api_key.save()\n\n\nclass Migration(migrations.Migration):\n    dependencies = DEPENDENCIES\n\n    operations = [\n        migrations.AddField(\n            model_name=MODEL_NAME,\n            name=\"hashed_key\",\n            field=models.CharField(max_length=100, null=True),\n        ),\n        migrations.AddField(\n            model_name=MODEL_NAME,\n            name=\"prefix\",\n            field=models.CharField(max_length=8, unique=True, null=True),\n        ),\n        migrations.RunPython(populate_prefix_hashed_key, migrations.RunPython.noop),\n        migrations.AlterField(\n            model_name=MODEL_NAME,\n            name=\"hashed_key\",\n            field=models.CharField(max_length=100, editable=False),\n        ),\n        migrations.AlterField(\n            model_name=MODEL_NAME,\n            name=\"prefix\",\n            field=models.CharField(max_length=8, unique=True, editable=False),\n        ),\n    ]\n</code></pre> <ul> <li>Apply the migration:</li> </ul> <pre><code>python manage.py migrate &lt;my_app&gt;\n</code></pre>"},{"location":"upgrade/2.0/","title":"Upgrading to 2.0","text":""},{"location":"upgrade/2.0/#introduction","title":"Introduction","text":"<p>This document lists the steps necessary to upgrade from 1.4.x to 2.0.</p> <p>The full list of changes can be found in the Changelog.</p>"},{"location":"upgrade/2.0/#steps","title":"Steps","text":""},{"location":"upgrade/2.0/#1-upgrade-your-python-to-36","title":"1. Upgrade your Python to 3.6+","text":"<p>The 2.0 release dropped support for Python 3.5.</p> <p>Before upgrading, make sure you are running on Python 3.6 or above.</p>"},{"location":"upgrade/2.0/#2-upgrade-your-django-to-22","title":"2. Upgrade your Django to 2.2+","text":"<p>To 2.0 release dropped official support for Django 2.0 and Django 2.1, which have both reached EOL (see Django: Supported Versions). Django 2.2 is still supported, and support for Django 3.0 was added.</p> <p>While we there are no internal changes due to this change, you should make sure you are running on Django 2.2 or above before upgrading.</p>"}]}